"""Unit tests for the DataObject class."""

import typing as tp
import pytest
from hypothesis import given, strategies as st

from korsbakken_python_utils.containers.dataobject import (
    DataObject,
    UniformTypeDataObject,
)


class TestDataObject:
    """Test suite for the DataObject class."""

    TestClass: type[DataObject] = DataObject

    def test_init_empty(self) -> None:
        """Test initialization with no arguments."""
        obj: DataObject = self.TestClass()
        assert len(obj) == 0
        assert str(obj) == f'{self.TestClass.__name__}()'

    def test_init_kwargs(self) -> None:
        """Test initialization with keyword arguments."""
        obj: DataObject = self.TestClass(a=1, b='test')
        assert obj.a == 1
        assert obj['b'] == 'test'
        assert len(obj) == 2

    def test_setitem_getitem(self) -> None:
        """Test dictionary-style setting and getting of items."""
        obj: DataObject = self.TestClass()
        obj['key'] = 'value'
        assert obj['key'] == 'value'
        assert obj.key == 'value'

    def test_delitem(self) -> None:
        """Test deletion of items."""
        obj: DataObject = self.TestClass(x=10)
        del obj['x']
        assert 'x' not in obj
        with pytest.raises(AttributeError):
            _ = obj.x

    def test_iter(self) -> None:
        """Test iteration over keys."""
        data: dict[str, int] = {'a': 1, 'b': 2, 'c': 3}
        obj: DataObject = self.TestClass(**data)
        keys: list[str] = list(obj)
        assert sorted(keys) == sorted(data.keys())

    def test_len(self) -> None:
        """Test length calculation."""
        obj: DataObject = self.TestClass()
        assert len(obj) == 0
        obj.x = 1
        assert len(obj) == 1

    def test_repr(self) -> None:
        """Test the __repr__ string representation."""
        obj: DataObject = self.TestClass(a=1)
        repr_str: str = repr(obj)
        assert self.TestClass.__name__ in repr_str
        assert 'a=1' in repr_str

    def test_str(self) -> None:
        """Test the __str__ string representation."""
        obj: DataObject = self.TestClass(a=1, b=2)
        str_val: str = str(obj)
        assert str_val == f"{self.TestClass.__name__}(a=1, b=2)"

    def test_to_dict_copy(self) -> None:
        """Test to_dict with copy=True (default)."""
        obj: DataObject = self.TestClass(a=1)
        d: dict[str, tp.Any] = obj.to_dict()
        d['a'] = 2
        assert obj.a == 1  # Original should not change

    def test_to_dict_no_copy(self) -> None:
        """Test to_dict with copy=False."""
        obj: DataObject = self.TestClass(a=1)
        d: dict[str, tp.Any] = obj.to_dict(copy=False)
        d['a'] = 2
        assert obj.a == 2  # Original should change

    def test_to_tuples(self) -> None:
        """Test conversion to list of tuples."""
        obj: DataObject = self.TestClass(a=1, b=2)
        tuples: list[tuple[str, tp.Any]] = obj.to_tuples()
        assert ('a', 1) in tuples
        assert ('b', 2) in tuples
        assert len(tuples) == 2

    @given(st.dictionaries(st.text(min_size=1).filter(lambda x: x.isidentifier()), st.integers()))
    def test_hypothesis_properties(self, data: dict[str, int]) -> None:
        """Property-based test using hypothesis to verify consistency.

        Parameters
        ----------
        data : dict[str, int]
            Random dictionary generated by hypothesis.
        """
        obj: DataObject = self.TestClass(**data)

        # Check length
        assert len(obj) == len(data)

        # Check membership and access
        for _key, _val in data.items():
            assert _key in obj
            assert obj[_key] == _val
            assert getattr(obj, _key) == _val

        # Check equality of dict representation
        assert obj.to_dict() == data

    def test_attribute_error_missing_key(self) -> None:
        """Test accessing a missing key raises AttributeError/KeyError appropriately."""
        obj: DataObject = self.TestClass()
        # When accessing as attribute, should raise AttributeError.
        with pytest.raises(AttributeError):
            _ = obj.missing_attr
        
        # Since it inherits from MutableMapping, __getitem__ should raise
        # KeyError when accessed like a dictionary.
        with pytest.raises(KeyError):
            _ = obj['missing_key']

    def test_overwrite_attributes(self) -> None:
        """Test overwriting existing attributes."""
        obj: DataObject = self.TestClass(a=1)
        obj.a = 2
        assert obj['a'] == 2
        obj['a'] = 3
        assert obj.a == 3


class TestUniformTypeDataObject(TestDataObject):
    """Test suite for the UniformTypeDataObject class."""

    TestClass = UniformTypeDataObject
